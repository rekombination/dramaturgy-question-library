generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// NextAuth Models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Application Models
enum UserRole {
  USER
  EXPERT
  MODERATOR
  ADMIN
}

enum TrustLevel {
  NEW
  BASIC
  TRUSTED
}

enum ProfileVisibility {
  PUBLIC
  MEMBERS_ONLY
  PRIVATE
}

model User {
  id              String     @id @default(cuid())
  name            String?
  username        String?    @unique
  email           String?    @unique
  emailVerified   DateTime?
  password        String?
  image           String?
  role            UserRole   @default(USER)
  trustLevel      TrustLevel @default(NEW)
  bio             String?    @db.Text
  expertiseAreas  String[]
  approvedPosts   Int        @default(0)
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  // Social Media Links
  instagramUrl    String?
  tiktokUrl       String?
  youtubeUrl      String?
  vimeoUrl        String?
  linkedinUrl     String?
  websiteUrl      String?

  // Privacy Settings
  profileVisibility   ProfileVisibility @default(PUBLIC)
  showActivity        Boolean           @default(true)
  showStats           Boolean           @default(true)
  showSocialLinks     Boolean           @default(true)
  emailNotifications  Boolean           @default(true)
  showInLeaderboards  Boolean           @default(true)

  // Onboarding
  hasCompletedOnboarding Boolean        @default(false)

  accounts               Account[]
  sessions               Session[]
  questions              Question[]     @relation("AuthoredQuestions")
  expertClaims           Question[]     @relation("ExpertClaims")
  replies                Reply[]
  votes                  Vote[]
  bookmarks              Bookmark[]
  flags                  Flag[]         @relation("Reporter")
  resolvedFlags          Flag[]         @relation("Resolver")
  toolkits               Toolkit[]
  feedback               Feedback[]
  notifications          Notification[]
  triggeredNotifications Notification[] @relation("NotificationActor")
  comments               Comment[]

  @@index([username])
}

enum QuestionStatus {
  DRAFT
  PENDING
  PUBLISHED
  HIDDEN
}

enum ContextType {
  REHEARSAL
  SHOW
  TOURING
  FUNDING
  TEAM
  AUDIENCE
  OTHER
}

model Question {
  id              String         @id @default(cuid())
  title           String
  body            String         @db.Text
  images          String[]       @default([])
  videos          String[]       @default([])
  status          QuestionStatus @default(DRAFT)
  contextType     ContextType    @default(OTHER)
  stakes          String?        @db.Text
  constraints     String?        @db.Text
  tried           String?        @db.Text
  sensitivityNote String?        @db.Text
  isPrivate       Boolean        @default(false)
  requestExpert   Boolean        @default(false)
  voteCount       Int            @default(0)
  replyCount      Int            @default(0)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  // Question closing
  isSolved        Boolean        @default(false)
  solvedAt        DateTime?
  solvedByReplyId String?
  solvedByReply   Reply?         @relation("SolvedByReply", fields: [solvedByReplyId], references: [id])

  // Expert claim system
  expertClaimedAt DateTime?
  expertClaimedById String?
  expertClaimedBy User?          @relation("ExpertClaims", fields: [expertClaimedById], references: [id])

  authorId        String
  author          User           @relation("AuthoredQuestions", fields: [authorId], references: [id], onDelete: Cascade)

  tags            QuestionTag[]
  replies         Reply[]
  votes           Vote[]
  bookmarks       Bookmark[]
  flags           Flag[]
  toolkitItems    ToolkitQuestion[]
  notifications   Notification[]

  @@index([authorId])
  @@index([status])
  @@index([contextType])
  @@index([createdAt])
  @@index([isPrivate])
  @@index([isSolved])
  @@index([expertClaimedById])
}

model Tag {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  description String?
  category    String?
  createdAt   DateTime @default(now())

  questions   QuestionTag[]

  @@index([slug])
  @@index([category])
}

model QuestionTag {
  questionId String
  tagId      String

  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  tag        Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([questionId, tagId])
}

enum ReplyStatus {
  PENDING
  PUBLISHED
  HIDDEN
}

model Reply {
  id                  String      @id @default(cuid())
  body                String      @db.Text
  status              ReplyStatus @default(PUBLISHED)
  isExpertPerspective Boolean     @default(false)
  voteCount           Int         @default(0)
  commentCount        Int         @default(0)
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt
  editedAt            DateTime?

  questionId          String
  question            Question    @relation(fields: [questionId], references: [id], onDelete: Cascade)

  authorId            String
  author              User        @relation(fields: [authorId], references: [id], onDelete: Cascade)

  votes               Vote[]
  flags               Flag[]
  comments            Comment[]
  solvedQuestions     Question[]     @relation("SolvedByReply")
  notifications       Notification[]

  @@index([questionId])
  @@index([authorId])
}

enum VoteType {
  HELPFUL
  INSIGHTFUL
}

model Vote {
  id         String   @id @default(cuid())
  type       VoteType @default(HELPFUL)
  createdAt  DateTime @default(now())

  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  questionId String?
  question   Question? @relation(fields: [questionId], references: [id], onDelete: Cascade)

  replyId    String?
  reply      Reply?    @relation(fields: [replyId], references: [id], onDelete: Cascade)

  commentId  String?
  comment    Comment?  @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, questionId])
  @@unique([userId, replyId])
  @@unique([userId, commentId])
  @@index([questionId])
  @@index([replyId])
  @@index([commentId])
}

model Comment {
  id        String   @id @default(cuid())
  body      String   @db.Text
  voteCount Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  editedAt  DateTime?

  replyId   String
  reply     Reply    @relation(fields: [replyId], references: [id], onDelete: Cascade)

  authorId  String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  parentCommentId String?
  parentComment   Comment?  @relation("CommentThread", fields: [parentCommentId], references: [id], onDelete: Cascade)
  childComments   Comment[] @relation("CommentThread")

  votes     Vote[]

  @@index([replyId])
  @@index([authorId])
  @@index([parentCommentId])
}

model Bookmark {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())

  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([userId, questionId])
  @@index([userId])
}

model Toolkit {
  id          String   @id @default(cuid())
  title       String
  slug        String   @unique
  description String?  @db.Text
  introText   String?  @db.Text
  isFeatured  Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  createdById String
  createdBy   User     @relation(fields: [createdById], references: [id])

  questions   ToolkitQuestion[]

  @@index([slug])
}

model ToolkitQuestion {
  toolkitId  String
  questionId String
  position   Int      @default(0)
  note       String?  @db.Text

  toolkit    Toolkit  @relation(fields: [toolkitId], references: [id], onDelete: Cascade)
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@id([toolkitId, questionId])
  @@index([toolkitId])
}

enum FlagStatus {
  PENDING
  RESOLVED
  DISMISSED
}

model Flag {
  id           String     @id @default(cuid())
  reason       String     @db.Text
  status       FlagStatus @default(PENDING)
  createdAt    DateTime   @default(now())
  resolvedAt   DateTime?

  reporterId   String
  reporter     User       @relation("Reporter", fields: [reporterId], references: [id], onDelete: Cascade)

  resolvedById String?
  resolvedBy   User?      @relation("Resolver", fields: [resolvedById], references: [id])

  questionId   String?
  question     Question?  @relation(fields: [questionId], references: [id], onDelete: Cascade)

  replyId      String?
  reply        Reply?     @relation(fields: [replyId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([reporterId])
}

enum FeedbackType {
  BUG
  FEATURE
  IMPROVEMENT
  OTHER
}

enum FeedbackStatus {
  NEW
  REVIEWING
  PLANNED
  IN_PROGRESS
  COMPLETED
  DISMISSED
}

model Feedback {
  id          String         @id @default(cuid())
  type        FeedbackType
  title       String
  description String         @db.Text
  url         String?
  status      FeedbackStatus @default(NEW)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  userId      String
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([type])
}

enum NotificationType {
  NEW_QUESTION // For experts: new question with requestExpert
  NEW_REPLY    // For question author: new reply on their question
}

model Notification {
  id        String           @id @default(cuid())
  type      NotificationType
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())

  // Recipient
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Related entities
  questionId String?
  question   Question? @relation(fields: [questionId], references: [id], onDelete: Cascade)

  replyId String?
  reply   Reply?  @relation(fields: [replyId], references: [id], onDelete: Cascade)

  // Actor (who triggered this)
  actorId String?
  actor   User?   @relation("NotificationActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([userId, read])
  @@index([createdAt])
}
